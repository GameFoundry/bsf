Polish TODO:
 - Finalize example with resolution settings and proper GUI
  - Ensure that going fullscreen and windowed works fine
 - Add an example model
 - Test if example shuts down fine

 - Add license text to all files

 - Make a separate release branch with no editor/script stuff, and without .txt files and other development data
  - Name the branch BansheeEnginePreview
  - Before I branch make a separate solution with example only projects
  - Also remove all non-example code (e.g. plugin loading and similar)
  - This is so I can then merge that code back in that branch when ready
  - For other stuff I need to delete, use git permanent delete

 - Add a .zip with dependencies
 - Add a .zip with source and dependencies
 - Test checking out source and extracting dependencies and see if it compiles
 - Test compiling on another PC

Automatically release resources on shutdown instead of forcing the user to manually call unload() and set handles to nullptr.
 - e.g. just invalidate all handles automatically

--------------------

Delay this until release:

Input issues:
 - I cannot have input of 1 one frame and input of 0 another. This happens when frames are too short. I might need to add very short smoothing times?
 - I cannot have input set to 1 during the entire frame if the frame is very long and user just moved the mouse a bit.
   - This might be even more of an issue with joystick axes as I currently have no mechanism of knowing what % of the frame are they being moved.
 - Maybe: Ability to define input sampling rate. Input sampling then runs on its own thread at 120/240/etc/Hz. Every frame the collected values are averaged.
   - This could be a part of OIS. Mouse sampling should already be doing something similar.
   - I can't think of ANY other way gamepad axes can work with long frame times, other than this approach
   - Check DirectInput::Poll
   - And DirectInput::GetDeviceState to get immediate mouse data
     - Check if this state is an absolute value, difference from last call or what.
   - Potentially also GetRawInputData as I might be able to use that instead of windows messages
 - Probably remove UE4 smoothing as I'm not even sure what it does

Problem with current OIS mouse approach is that if I call capture() too often, no new sampling data is available 
but the mouse might still be moving and it just reports 0. Which is wrong if the mouse is moving.
 - These is no way around this if querying the state too quickly. I can either keep the current system and remember
   last 5-10ms of input and average that, or I can use the above solution with polling which should have the similar effect.

-----------------

Not so critical
  - I have a feeling DX9 might start crashing once I resize to sub-fullscreen res and go back to FS - test it
  - Add VSync toggle to RenderWindow if it doesn't already exist.
  - Test creating a fullscreen window on window creation.
  - Refactor GUIElement & GUIElementBase
     - Sprite rendering methods should probably be marked as internal (possibly others too)
       - A lot could be made private
     - Has two methods for retrieveing ElementType
     - getVisibleBounds doesn't make sense
  - There's still a crash regarding an uninitialized mCachedPtr on a C# class when shutting down. Attempt to find consistent repro steps.
  - Perform optimizations as needed to get reasonable performance
  - Consider removing SceneManager from Core? I have two scene manager base classes.
  - GpuParamBlockBuffer and GpuParams::cloneForCore are very clumsy in how they deal in keeping two separate param blocks. Rethink this a bit.
  - Test texture compression and mip generation with DX9 and OpenGL
