--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

<<<<<Assembly refresh>>>>>

When serializing Camera I cannot save the reference to RenderTexture. Make it a Resource?
Possibly set up automatic refresh in debug mode after initialization? As an ad-hoc unit test

Occasional crash happens in ScriptObjectManager::refreshAssemblies when backupData.data ends up being null (not all the time though)

addComponent gets called during end refresh
 - This seems to add another Camera to the scene
 - While the old one contines to exist as well

<<<<Multi-resource saving>>>>:
 - Modify Font so it doesn't contain a texture, but instead keeps a handle to it
 - Register it in its meta file
 - When saving such a resource with dependencies save the contained files to a sub-directory with the same name as top level resource
   - If it already exists in the manifest at a different location do it anyway, keep the other copy as-is in case user wanted it that way
   - I'm not sure whether to do this for all Resource::save calls or only ones originating from ProjectLIbrary?

Other:
Window resize end callback
Add cutoff plane when rendering discs for rotation handle.

I can get mono errors by checking g_print calls in goutput.c
 - Calling thunks incorrectly can cause those weird errors with no real callstack

Running embedded mono with VS attached causes managed null refs to be registered as access violations

Crash on GLTextureBuffer::download on shutdown (OpenGL error invalid enum)
Create a stack allocatable custom vector implementation and make getResourceDependencies and getCoreDependencies use it

C# SceneView:
Test new Scene window and fix every issue
Add ProjectWindow and HierarchyWindow to C#
 - Make TreeViews a C# element?
Set up a default layout and save it

Need a way to drag and drop items from Scene tree view to Scene view

AFTER I have scene widget in C#:
 - Implement free move handle and remaining handles
 - Test custom handles from C#
 - Test handle snapping

IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK - Use the shader created in Unity

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add 2D move and scale
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

---------------------------------------------------------------------