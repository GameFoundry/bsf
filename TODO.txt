--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

----------------------------------------------------------------------
Assembly refresh

When serializing Camera I cannot save the reference to RenderTexture. Make it a Resource?
Possibly set up automatic refresh in debug mode after initialization? As an ad-hoc unit test

----------------------------------------------------------------------
Project library

Almost all of PRojectLibrary functionality is completely untested

My GUID generation is screwed up. If multiple GUIDs are generated in succession then the timestamp will remain
the same and the only variable will be the 4byte random number, which can sometimes end up identical to the previous number.

----------------------------------------------------------------------
GUIArea refactor:

Revert all changes and start from scratch:
 1. Get all layouts to use pointers and be reparentable. Compile/commit
    - Make GUIElementBase::addElement return a ptr to the element so I don't need to use two lines to init and add an element
 2. Add new GUILayoutOption (offset) and ensure it works. Add GUILayoutOptions to layouts as well, and ensure parent layouts respect them (when it makes sense).
 3. Remove normal position/size from GUIElementBase and move it to GUIElement
 4. Move to the new positioning/size system (get rid of GUIOptions) and add support for offset size type
   - Also ensure these options work with layouts and that GUILayoutExplicit respects child layout positions same as it does elements
 5. Rename GUiLayoutExplicit to GUIPanel. Add default layout to it. Make coordinates relative
     and ensure ColorPicker window works looks fine. (And refactor elements so they contain relative size.)
 6. Change how GUIArea depth works. Allow GUIPanel to have a depth range (keep at the depth on GUIArea for now as well)
 7. Modify C# so it no longer uses GUIPanel or GUIPanelContainer and uses GUILayoutExplicit (now GUIPanel) instead
 8. Remove GUIArea and replace with GUILayoutExplicit in C++ and C#

GUIPanel (ex GUILayoutExplicit)
 - When creating a GUIPanel allow certain size to be specified. When layout is positioned that size is used as if it was fixed GUI element size.
 - Should have a default layout as its child. This layout acts as it was parented by a GUIArea (it tries to cover the entire size of GUILayout)
  - But it also has standard AddElement methods which will allow elements to be positioned directly.
 - When calculating bounds I need to return them relative to the parent GUIPanel
   - When specifying bounds they should be relative to parent GUIPanel
   - This will require updating GUILayoutUtility

Replace current GUIOption::fixedWidth/etc. system and implement something new that also works for layouts
 - Also it deals with the issue of relative coordinates
 - setPosition(GUIPosition x, GUIPosition y) <- used only if direct parent of GUIPanel
   - GUIPosition::fixed(int value) <- position in pixels offset from parent GUIPanel
 - setWidth(GUISize size), setHeight(GUISize size)
   - GUISize::fixed(int value) <- fixed size in pixels
   - GUISize::flexible(int min, int max) <- flexible size in pixels with minimum and maximum value (0 means inifinite)
   - GUISize::offset(int offset) <- size that is determined by the distance from the edge from its parent
 - setAnchor(Vector2 min, Vector2 max)
   - anchor + specifiying size as an offset is weird but I can't think of a way around it
 - Need to modify layout updates so they properly handle these new settings. Most importantly for layouts as they don't support layout 
   options right now. And GUI elements don't support float versions of position/size methods.

TODO - Better way to handle layout depth?
  - Specify layout depth as offset + range. Then just add the depths and clamp if outside the range
TODO - Will I need a separate set of coordinates to properly handle relative coordinates?
  - Yes, most likely. Other option is somehow storing a reference to the parent but I don't think
    that's a good solution. Rename current position/size to cached position/size and make current
	getter/setters point to the new relative position/size instead. Cached should only be available
	to internal methods.

OPTIONAL - Consider making coordinates/size be GUIElement only

Use cases:
InspectorWindow:
 - It has a scroll area that will have a GUIPanel as its child. User can then add custom GUIPanels as children to the root GUIPanels main layout.

ColorPicker
 - This should work fine as long as I ensure that I add explicit elements to the root GUIPanel (one that has the main layout with all other elements)

ProjectWindow
 - ScrollArea would have a GUIPanel child and then it would work similarly to InspectorWindow

Three child GUIPanels in a widget, title-bar, contents and background
 - Add three GUIPanels to the root panel, each with its own depth
 - Title GUIPanel: Add GUISpaces for padding, GUIFlexibleSpace to anchor to the top, specify GUIPanel height but leave width at 0 for flexible expand
 - Content GUIPanel: Similar as title, but leave both width and height as 0, add GUISpace as padding
 - Background GUIPanel: Leave as is

----------------------------------------------------------------------
Project window

When working with scroll areas I cannot create multiple child areas of different depths. Can I rely on just the order I add the elements in the layout?
 - Or can I just have a child GUIArea inside a scroll area?

Simple tasks:
 - Add GUI button as overlay. Hook up its input event to select (click) + enter directory (double click) + context (right click, for later)
 - Add element highlights: ping (blue bg), selection (orange bg), cut (fade out icon/label)
 - Add C# ContextMenu
 - Add DropDownWindow type

----------------------------------------------------------------------
Resources
 - Load/Unload/UnloadUnused
 - Uses same paths as ProjectLibrary
 - It uses different logic depending on Application.isEditor
   - If not in editor then a different path is used
   - That path is ..\..\Data (relative to the executable)
   - When in editor it also does special ProjectLibrary check to ensure that resource is included in final project
 - Internally just calls Resources (C++) Load/Unload/UnloadUnused
 - Need a flag in ProjectLibrary to include a resource in the final build
   - Need to be able to set that flag from C# (Likely through ProjectLibrary) interface
 - The final build procedure for the game would then be:
   - Copy all the prebuilt binaries (Banshee libraries, Banshee assemblies, 3rd party libraries and prebuilt executable) from Editor install folder to output folder
    - Which set of binaries is used depends on selected platform (e.g. win/mac/linux or 32/64bit)
   - Recompile script assemblies if needed and copy them from project Internal folder to output folder
   - Copy the Builtin resources for engine from Editor install folder to output folder
   - Copy all the resources marked with the flag mentioned above to \Data subfolder in the output folder, preserving the same asset structure

----------------------------------------------------------------------
Simple stuff

C#:
Dialog.Show(title, text, btn1 text, btn1 callback, btn2 text, btn2 callback, btn3 text, btn3 callback)

Other simple stuff:
 - Inject an icon into an .exe (Win32 specific)
 - C# wrapper for GUISkin (and a way to assign the current skin to a window)
 - Move all the code files into subfolders so their hierarchy is similar to VS filters
 - Font doesn't have a C# interface
 - Material/Shader/Technique/Pass don't have a C# interface
 - Get rid of PoolAlloc and other unused allocators (plus fix bs_new and others which have weird overloads)
 - Call stack from C# to use in Debug.Log calls
 - Get rid of event callback from HString and figure out a better way
 - GUI TextureField similar to ResourceField but it displays the texture it has assigned
 - Better handle and gizmo shaders

----------------------------------------------------------------------
Handles

When scaling using center make sure to offset the object before scale
Handles should probably not having shading, or have better shading.

Rotate handle:
 - How to handle local/global with rotate handle?
   - This maybe just determines initial rotation of the handle?
   - I don't think my code properly handles rotation handle transforms (e.g. arc drawing)

Ideally free scale handle indicator should always render and be interactable and never be hidden by axis scale indicators (Not high priority)

Later:
 - Raycast snapping Ribek suggested

----------------------------------------------------------------------
Include files:

Test:
 - Try preprocessing using one RenderAPi and then load the shaders using another and see if they're created normally
 - Test if default values work
 - Test project library dependant resources

----------------------------------------------------------------------
Scene View

AFTER I have scene widget in C#:
 - Test custom handles from C#
 - Test handle snapping

Need a way to drag and drop items from Scene tree view to Scene view
 - When dragging a mesh it should by default create a SceneObject with a renderable
 - I might want a C# DragAndDrop class? It can contain Resource or SceneObject only for now, similar to Selection

----------------------------------------------------------------------
Other

Got a crash on shutdown that was caused by locking a mutex in an Event destructor. Event was Platform::onMouseCaptureChanged. 
Issue happened when I closed the app via the X button (if that's relevant). It doesn't seem to happen always.
 - This is likely due to some other error. When VS finds an exception it triggers a dialog box which triggers the msg loop in-engine and causes another exception.

Create a stack allocatable custom vector implementation and make getResourceDependencies and getCoreDependencies use it.
 - These methods are called often and cause allocations whenever they are.

Add ProjectWindow and HierarchyWindow to C#
 - Make TreeViews a C# element?
Set up a default layout and save it

----------------------------------------------------------------------
Multi-resource saving
 - Modify Font so it doesn't contain a texture, but instead keeps a handle to it
 - Register it in its meta file
 - When saving such a resource with dependencies save the contained files to a sub-directory with the same name as top level resource
   - If it already exists in the manifest at a different location do it anyway, keep the other copy as-is in case user wanted it that way
   - I'm not sure whether to do this for all Resource::save calls or only ones originating from ProjectLIbrary?

/*********************************************************************/
/************************ LESS IMPORTANT *****************************/
/*********************************************************************/

----------------------------------------------------------------------
Mono notes

I can get mono errors by checking g_print calls in goutput.c
 - Calling thunks incorrectly can cause those weird errors with no real callstack

Running embedded mono with VS attached causes managed null refs to be registered as access violations

There seems to be a bug in Mono when passing complex structs from C# to C++. e.g. passing Rect3 as a parameter
will corrupt the parameter after it, even if layout and size is exact as the C++ version. 
Rect3 has child structs (Vector3) which could be the reason. Be aware of other similar problems.

Mono cannot marshal structures? Taken from their documentation:
 Internal calls do not provide support for marshalling structures. This means that any API calls that take a structure 
 (excluding the system types like int32, int64, etc) must be passed as a pointer, in C# this means passing the value as a "ref" or "out" parameter.

----------------------------------------------------------------------
MenuItem

LATER: Add keyboard controls to GUIMenuBar (left/right arrows should move between entries if user is not browsing a sub-menu)
 - esc should cancel out of the menu bar
 - alt should focus the menu bar

----------------------------------------------------------------------
VisualStudio integration

VS integration will likely not work with VSExpress or Community edition
 - VSExpress doesn't support EnvDTE so the only option is to open it using a shell command which doesn't seem to offer precise parameters
 - Community edition should work similarily to Pro, but might have a different executable and/or registry paths

For later:
 - Make sure that 3rd party assemblies can be imported in the project, and that they are properly referenced in VS project generation and compilation

----------------------------------------------------------------------
Script compilation

For later:
 - I need to hook up script compilation with assembly refresh, and the build system.
   - e.g. when recompiling inside the editor it should automatically start compiling when changes are detected,
     show some kind of visual indicator and refresh assemblies when its done. When publishing it should recompile
	 assemblies for release. Also hook up console to compiler output?