--------- ALL LONG TERM TASKS / FIXES BELONG TO GOOGLE DOCS: ImplementationTODO OR PossibleImprovements ----------

----------------------------------------------------------------------
Polish

Other polish:
 - Add menu items:
  - Edit: Cut/Copy/Paste/Duplicate/Delete(need to make sure it works in Hierarchy, with shortcuts), View/Move/rotate/scale
  - Game Object (also add to context): Create(Empty, Empty Child, Camera, Renderable, Point/Spot/Directional Light), Apply prefab, Break prefab, Revert prefab
 - Inspector persistance (See below for details)

Stage 2 polish:
 - Game window
 - Game play/pause/step (+ save/restore objects on play/pause switch)
 - Resource hotswap
 - When managed exception happens log an error and continue execution
  - Doing a pass over all methods referencing Internal_ methods ensuring they do proper checking on C# side would be good
 - Game publishing (Build window, collect resources, output exe, default viewport) (described below)

Optional:
 - When starting drag from hierarchy tree view it tends to select another object (can't repro)
 - Handle seems to lag behind the selected mesh
 - When resizing library window while docked, selection area appears
 - Move all the code files into subfolders so their hierarchy is similar to VS filters
 - Undo/Redo
  - CmdRecordSO records an SO and all its children but it should only record a single SO
  - CmdRecordSO should instead of recording the entire object record a diff
  - There should be a CmdRecordSO equivalent for resources (probably)
  - Add commands for breaking or reverting a scene object 
  - Test & finalize undo/redo system
 - Add "focus on object" key (F) - animate it: rotate camera towards then speed towards while zooming in (+ menu entry)
 - Ortographic camera views (+ gizmo in scene view corner that shows camera orientation)
 - MenuBar - will likely need a way to mark elements as disabled when not appropriate (e.g. no "frame selected unless scene is focused")
   - Likely use a user-provided callback to trigger when populating the menus (I already added a callback to MenuItem, just need to implement it)
 - Need to list all script components in the Components menu
 - Cursors should be replaced with better ones, or at least hot-spots fixed
 - Drag and dropping a prefab onto the scene (or hierarchy) should work the same as with meshes
 - Add tooltips to toolbar items and other buttons with icons
 - Either disable light tool icons before release or make them functional (With gizmos)

Seriously optional:
 - Drag to select in scene view
 - Automatically generate readable inspector names and add [Name] attribute that allows custom naming
 - Add Range[] attribute to C# that forces a float/int to be displayed as a slider
 - GUI tabbing to switch between elements
 - Better Prefab inspector - display SceneObject inspector of top-level object, and possibly prefab hierarchy?
 - Do another optimization pass

Finalizing:
 - Add copyright notices in all files & change license to GPL
 - Need to generate a proper merge of dev and preview branches
   - Use "git revert --no-commit <COMMITID>..HEAD" to reverse anything on the preview branch that was done after the branch creation, then merge

----------------------------------------------------------------------
Inspector persistance

 - When I expand inspector elements and them come back to that object it should remember the previous state
   - In the Inspector base add a dictionary "Persistent<string, object>"
   - InspectorWindow will keep a reference to this dictionary whenever it creates a new inspector for SO or resource
    - Or if one already exists it will restore it
	- This dictionary will not persist editor shutdown
   - Generic inspector and inspectable fields can use the serialized property name for the key
    - Will need a way to retrieve the full property name, up to the parent Component/Resource
	- Will need to extend inspectable fields so they know their parent inspector so they have access to the dictionar
   - Custom inspectors can get rid of manual "isExpanded" bools and use the dictionary instead

----------------------------------------------------------------------
Build system
 - Test Resources (if loading works and if they're properly packaged in build)
 - Game/Editor assemblies in editor are compiled with debug information, add a toggle for this in build settings and recompile without it if needed
  - Will also need to compile a different version of the built-in BansheeEngine assembly
 - The final build procedure for the game should be:
   - Copy all the prebuilt binaries (Banshee libraries, Banshee assemblies, 3rd party libraries and prebuilt executable) from Editor install folder to output folder
    - Which set of binaries is used depends on selected platform (e.g. win/mac/linux or 32/64bit)
   - Recompile script assemblies if needed and copy them from project Internal folder to output folder
   - Copy the Builtin resources for engine from Editor install folder to output folder
   - Copy all the resources marked with the flag mentioned above to \Data subfolder in the output folder, preserving the same asset structure
     - Also all dependencies of those resources (add C# method FindDependantResources?)
   - Make sure to go over texture resources and ensure they are saved in the valid format
     as we don't want to do format conversion at runtime (Not cruical, but it should be done eventually)
     - This should something similar to Unity where when changing the platform all resources get reimported
   - Make sure to clear all prefab diffs (possibly store them elsewhere in the first place)
	 - And all prefab instances should have updateFromPrefab called on them.
  - Need to create an executable that creates a fullscreen window, loads main scene and renders the main camera to it
   - Might need a way to load fullscreen & resolution state on start-up (so it can be modified internally and loaded immediately next time)
    - Add GameSettings.asset that is generated on build
	 - Has "firstStart" turned off
	 - Contains wanted video mode and initial scene to load
	 - This file is loaded by the application initially
	 - Similar to project/editor settings this can contain user data as needed

----------------------------------------------------------------------
Game window
 - Main camera
  - Allow camera to be marked with "Main" toggle
  - When Game window is created search the scene for such a camera
   - Same needs to happen whenever a new scene is loaded
  - Create a render target similar to scene window and render to it if the camera is found
   - Otherwise output a message that main camera is missing
 - Extend Time class (C++ and C#)
  - Current time and frame idx should be renamed with Real prefix
  - New time and frame idx should be added that do not tick when paused
 - EditorApplication Play/Pause/Step
  - When game is paused non-real time doesn't tick, and component OnInitialize/Update/OnDestroy methods aren't called
   - Some components might rely on these being called when they're added/removed from the scene. Perhaps add
     a separate set of initialize/destroy methods for internal only use that get called regardless?
   - Internal (editor) components either ignore this rule, or use the internal-only versions exclusively
   - When play is hit:
     - Current scene data is serialized into a Prefab stored in memory
	 - Time starts ticking and initialize/update/destroy methods start to get called normally
   - When pause is hit:
     - Time stops ticking and so do components method calls
   - When stop is hit:
     - Time stops ticking and so do components method calls
	 - Current scene is unloaded and prefab from memory is loaded
   - When frame-step is hit:
     - Time and component updates are unpaused for a single frame and then paused again

/*********************************************************************/
/************************ LESS IMPORTANT *****************************/
/*********************************************************************/

----------------------------------------------------------------------
Mono notes

I can get mono errors by checking g_print calls in goutput.c
 - Calling thunks incorrectly can cause those weird errors with no real callstack

Running embedded mono with VS attached causes managed null refs to be registered as access violations

There seems to be a bug in Mono when passing complex structs from C# to C++. e.g. passing Rect3 as a parameter
will corrupt the parameter after it, even if layout and size is exact as the C++ version. 
Rect3 has child structs (Vector3) which could be the reason. Be aware of other similar problems.

Mono cannot marshal structures? Taken from their documentation:
 Internal calls do not provide support for marshalling structures. This means that any API calls that take a structure 
 (excluding the system types like int32, int64, etc) must be passed as a pointer, in C# this means passing the value as a "ref" or "out" parameter.

Mono has problems with returning a struct from an internal C++ method. Returned value might end up being corrupted. It works weirdly as
I am able (for example) return a Rect2 with no problems, but it doesn't work when returning a Degree struct. Returning the value as input
parameter solves the problem (presumably boxing the return value would also work).

Sometimes exceptions cause a crash in Event, although this is due to an exception triggering a dialog box which triggers
the message loop and causes another exception. Make sure to look for the original exception.

Finalizers on attribute members will get called more than once. This causes issues if some of the members reference native 
objects as already deleted native objects will try to be deleted again. 

----------------------------------------------------------------------
MenuItem

 - Add keyboard controls to GUIMenuBar (left/right arrows should move between entries if user is not browsing a sub-menu)
  - esc should cancel out of the menu bar
  - alt should focus the menu bar

----------------------------------------------------------------------
VisualStudio integration

 - VS integration will likely not work with VSExpress or Community edition
  - VSExpress doesn't support EnvDTE so the only option is to open it using a shell command which doesn't seem to offer precise parameters
  - Community edition should work similarily to Pro, but might have a different executable and/or registry paths
 - Make sure that 3rd party assemblies can be imported in the project, and that they are properly referenced in VS project generation and compilation

----------------------------------------------------------------------
Library window

 - Might need to improve search (need to test). Do multiple search keywords work properly?
 - Consider delaying search until user stops pressing keys (so not to have thousands of search results in the initial stages)
 - Save & restore scroll position when Refresh happens

----------------------------------------------------------------------
Handles

 - Ideally free scale handle indicator should always render and be interactable and never be hidden by axis scale indicators (Not high priority)
 - Raycast snapping Ribek suggested

----------------------------------------------------------------------
Include files:

 - Test if default values work
 - Test project library dependant resources (e.g. changing an include and seeing if shader is reimported)

----------------------------------------------------------------------
Scene View

Test custom handles from C#

----------------------------------------------------------------------
C# Material/Shader

TODO - Implement param block and sampler support
TODO - When creating a Material without a shader, a default one should be used, at least in editor
TODO - Setting Material array parameters isn't possible from C#
