
 GIZMO TODO:
  - Figure out how to deal with builtin components like Camera and Renderable (e.g. how will they have gizmos since they're not managed components?)
    - Make those two a non-component types. Anywhere they are used in the Renderer they should just be passed as pointers.
	- Then make a Component wrapper around the non-component types, and also a C# wrapper around the same types

REFACTOR material getParams* and related classes. Those params should update all gpu program params that share that variable, not just the first found
Add a way to render GUI image without alpha
Crash related to Handles when object is selected
Exception related to handle manager on shutdown
Cannot pick gizmo icon
Cone handle doesn't render properly
Line slider collider intersection doesn't work properly

Test gizmos
 - HOOK UP GIZMO SELECTION and test it

Test handles
 - Test basic move handle
 - Test a custom handle from C#
 - FINISH HANDLE IMPLEMENTATION AND GLUE EVERYTHING TOGHETHER

IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK
 - LIKELY USE PIXEL SceneGrid WITH AA
 - OR (better) instead of drawing rows and columns of lines, just draw a plane with procedural texture

Need a way to drag and drop items from Scene tree view to Scene view

LATER:
 - Need a way to render text for gizmos and handles, and in scene in general
 - Add drag to select
 - Need a better system to catch broken shaders. DX11 just draws nothing with depth, DX9 draws all white.

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

---------------------------------------------------------------------
Multi-resources

 Importer::import
  - Each SpecificImporter is responsible for importing all needed resources and registering them with Resources manager
  - However only the main resource is returned from that method
  - Rest of the resources are referenced by the UUID in ResourceMeta and can be retrieved there if needed

 Resources::save
  - Add to documentation that it will only save that exact resource and not any dependencies, you must call save() for them manually

 Resources::load
  - Will automatically load all dependencies, optionally add a boolean that allows you to load only the main asset

ProjectLibrary
 - Needs to be extended so it shows sub-resources in tree view
 - Need to extend my mapping so one asset maps to multiple assets in library (need to remember how I do that currently, is it just by name or meta-file identifier?)

---------------------

With this approach I can:
 - Reference and load the sub-resources directly
 - Technically I can also delete sub-resources