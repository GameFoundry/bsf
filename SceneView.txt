
TODO:
 - Core thread gets stuck on shutdown when OpenGL is used...Somewhere in kernel

 GIZMO TODO:
  - Figure out how to deal with builtin components like Camera and Renderable (e.g. how will they have gizmos since they're not managed components?)

TESTING:
Ensure all 3 render systems compile and run
 - Test selection on all 3 render systems
 - RE-ENABLE SCISSOR TEST FOR PICKING SHADERS!!
 - Picking need to test something with alpha
 - Ensure that selecting an item in scene properly marks it in scene view
 - Ensure that selecting an item in scene or resource tree view properly updates Selection

Test gizmos
 - START UP GIZMO MANAGER SOMEWHERE
 - Test rendering of basic 2D and 3D gizmos
 - Test rendering of icon gizmos
 - Test them all from C#
 - HOOK UP GIZMO SELECTION and test it

Test handles
 - Test basic move handle
 - Test a custom handle from C#
 - FINISH HANDLE IMPLEMENTATION AND GLUE EVERYTHING TOGHETHER

IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK AND ENSURE IT RENDERS FINE ON ALL APIS
 - LIKELY USE PIXEL SceneGrid WITH AA

LATER:
 - Need a way to render text for gizmos and handles, and in scene in general
 - Add drag to select

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

ScriptHandleManager
 - Needs to be started up somewhere

SceneEditorWidget
 - Need to glue everything together

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

----------------------------------------------------------------------
SceneView editor flow:
  Hook up gizmo, handle and selection rendering methods to be executed after the scene is rendered
  Calculate mouse coords manually relative to the window and to the render texture GUI element
     - Don't use GUI events as we require more precise control (do we?)

  Detect mouse clicks on the scene render target
      Forward those mouse coordinates to HandleManager
      It checks if screen ray intersects any handles and returns the handle if it does
         If handle is found it is activated and method returns
         Otherwise we mark the coordinates as selection start

  Detect mouse drag on the scene render target
    - If we have an active handle
         Forward mouse coordinates to the active handle so it can do its thing
         return
    - Otherwise its assumed we are dragging a selection
         Update selection endpoint and send it to ScenePicking
         Use Selection to select picked objects if any
         return

  Detect mouse release on scene render target
     If we have an active handle
        Clear active handle
        return
     Otheriwse its assumed we are dragging a selection
        Do nothing
        return