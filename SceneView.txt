
 GIZMO TODO:
  - Make a C# wrapper for Camera and Renderable

REFACTOR material getParams* and related classes. Those params should update all gpu program params that share that variable, not just the first found
Need a way to drag and drop items from Scene tree view to Scene view
When dragging a handle make sure it works when cursor leaves the scene view
Also make sure that handle manager receives mouse up event if its done outside of scene view
When selecting/deselecting stuff handle display is delayed

Add C# methods for retrieving handle size and snap amounts
Actually make use of snapping in MoveHandle
Test if fixed size handles & snapping work

-----------

Start work on C# Camera, and C# EditorApplication.sceneCamera
  - I'll need to replace all current uses of scene camera with CameraHandler?? Since this camera will have to be a ManagedComponent...

Test handles
 - Test a custom handle from C#
 - FINISH HANDLE IMPLEMENTATION AND GLUE EVERYTHING TOGHETHER

IMPLEMENT SELECTION RENDERING

IMPROVE SceneGrid LOOK
 - LIKELY USE PIXEL SceneGrid WITH AA
 - OR (better) instead of drawing rows and columns of lines, just draw a plane with procedural texture

LATER:
 - Need a way to render text for gizmos and handles, and in scene in general
 - Add drag to select
 - Need a better system to catch broken shaders. DX11 just draws nothing with depth, DX9 draws all white.

----------------------------------------------------------------------
Handles

SliderLine - position, direction, length
  - When initially activated it records position nearest so the line as the starting point
  - Further mouse dragging also finds nearest position to the line
  - Difference between those two results in a float value (how much to move along direction from position to reach new position)
  - Slider line has a capsule + sphere collider size of which can be set manually

SliderPlane - position, normal, size
  - Similar to line slider only the direction is determined dynamically as well as distance
  - Outputs a Vector2 (direction * distance moved)
  - A OOB is used as a collider

SliderDisc - position, normal, radius
  - When initially activated it records position nearest so the disc as the starting point
  - Further movement calculates the dynamic direction from the starting point to the current point on the plane the disc lies on
  - Distance along that direction is returned as amount of movement (similar to line slider)
  - Outputs a single float
  - A torus is used as a collider

Free move/rotate/scale handles need to exist as well
 - Scale is easy, just perform uniform scale. Use SliderPlane oriented towards camera
 - Move also use SliderPlane oriented towards camera
 - Rotation use SliderDisc oriented towards camera

----------------------------------------------------
STAGE 1

CONCRETE TODO:
HandleSliderPlane/HandleSliderDisc
 - update() implementation

----------------------------------------------------
STAGE 2
Implement RotateHandle & ScaleHandle in C#
 - Nearest point to disc/arc code
Add free move, free rotate, free scale functionality
Handles that remain the same size regardless of distance from camera
 - For both drawing and collision

 More complex types for drawing like DrawArrow in HandleDrawManager

----------------------------------------------------------------------
SelectionRenderer

Retrieve a list of selected objects from SelectionManager
Find ones with Renderable components
Retrieve Meshes, and world transforms from them
Draw that same mesh with either a wireframe or a grayed out shader with a slight depth bias

---------------------------------------------------------------------
Multi-resources

 Importer::import
  - Each SpecificImporter is responsible for importing all needed resources and registering them with Resources manager
  - However only the main resource is returned from that method
  - Rest of the resources are referenced by the UUID in ResourceMeta and can be retrieved there if needed

 Resources::save
  - Add to documentation that it will only save that exact resource and not any dependencies, you must call save() for them manually

 Resources::load
  - Will automatically load all dependencies, optionally add a boolean that allows you to load only the main asset

ProjectLibrary
 - Needs to be extended so it shows sub-resources in tree view
 - Need to extend my mapping so one asset maps to multiple assets in library (need to remember how I do that currently, is it just by name or meta-file identifier?)

---------------------

With this approach I can:
 - Reference and load the sub-resources directly
 - Technically I can also delete sub-resources