mixin PerCameraData
{
	code 
	{
		[internal]
		cbuffer PerCamera
		{
			float3	 gViewDir;
			float3 	 gViewOrigin;
			float4x4 gMatViewProj;
			float4x4 gMatView;
			float4x4 gMatProj;
			float4x4 gMatInvProj;
			float4x4 gMatInvViewProj;
			
			// Special inverse view-projection matrix that had projection entries that affect z and w eliminated.
			// Used to transform a vector(clip_x, clip_y, view_z, view_w), where clip_x/clip_y are in clip space, 
			// and view_z/view_w in view space, into world space				
			float4x4 gMatScreenToWorld;
			
			// Converts device Z to world Z using this formula: worldZ = (1 / (deviceZ + y)) * x
			float2 	 gDeviceZToWorldZ;
			float2	 gNDCZToWorldZ;
			
			// x - near plane distance, y - far plane distance
			float2	 gNearFar;
			
			// xy - Viewport offset in pixels
			// zw - Viewport width & height in pixels
			int4 	 gViewportRectangle;
			
			// xy - (Viewport size in pixels / 2) / Target size in pixels
			// zw - (Viewport offset in pixels + (Viewport size in pixels / 2) + Optional pixel center offset) / Target size in pixels	
			float4 	 gClipToUVScaleOffset;	
			float	gAmbientFactor;
		}
		
		/** Converts Z value in range [0,1] into Z value in view space. */
		float convertFromDeviceZ(float deviceZ)
		{
			return (1.0f / (deviceZ + gDeviceZToWorldZ.y)) * gDeviceZToWorldZ.x;
		}
		
		/** Converts Z value from view space to NDC space. */
		float convertToNDCZ(float viewZ)
		{
			return -gNDCZToWorldZ.y + (gNDCZToWorldZ.x / viewZ);
		}
	};
};